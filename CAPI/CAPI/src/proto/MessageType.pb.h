// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: MessageType.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_MessageType_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_MessageType_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_MessageType_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace Protobuf {

enum MessageType : int {
  AddPlayer = 0,
  Move = 1,
  Attack = 2,
  Pick = 3,
  Use = 4,
  Throw = 5,
  Send = 6,
  InvalidPlayer = 7,
  ValidPlayer = 8,
  StartGame = 9,
  Gaming = 10,
  EndGame = 11,
  UseCommonSkill = 12,
  UseUltimateSkill = 13,
  InitialLized = 14,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = AddPlayer;
constexpr MessageType MessageType_MAX = InitialLized;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum GameObjType : int {
  NullGameObjType = 0,
  Character = 1,
  Wall = 2,
  Prop = 3,
  Bullet = 4,
  BirthPoint = 5,
  OutOfBoundBlock = 6,
  Grass = 7,
  GameObjType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GameObjType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GameObjType_IsValid(int value);
constexpr GameObjType GameObjType_MIN = NullGameObjType;
constexpr GameObjType GameObjType_MAX = Grass;
constexpr int GameObjType_ARRAYSIZE = GameObjType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GameObjType_descriptor();
template<typename T>
inline const std::string& GameObjType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GameObjType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GameObjType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GameObjType_descriptor(), enum_t_value);
}
inline bool GameObjType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GameObjType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GameObjType>(
    GameObjType_descriptor(), name, value);
}
enum ShapeType : int {
  NullShapeType = 0,
  Circle = 1,
  Square = 2,
  ShapeType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ShapeType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ShapeType_IsValid(int value);
constexpr ShapeType ShapeType_MIN = NullShapeType;
constexpr ShapeType ShapeType_MAX = Square;
constexpr int ShapeType_ARRAYSIZE = ShapeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ShapeType_descriptor();
template<typename T>
inline const std::string& ShapeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ShapeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ShapeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ShapeType_descriptor(), enum_t_value);
}
inline bool ShapeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ShapeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ShapeType>(
    ShapeType_descriptor(), name, value);
}
enum PlaceType : int {
  NullPlaceType = 0,
  Land = 1,
  Grass1 = 2,
  Grass2 = 3,
  Grass3 = 4,
  Invisible = 5,
  PlaceType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PlaceType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PlaceType_IsValid(int value);
constexpr PlaceType PlaceType_MIN = NullPlaceType;
constexpr PlaceType PlaceType_MAX = Invisible;
constexpr int PlaceType_ARRAYSIZE = PlaceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PlaceType_descriptor();
template<typename T>
inline const std::string& PlaceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PlaceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PlaceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PlaceType_descriptor(), enum_t_value);
}
inline bool PlaceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PlaceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PlaceType>(
    PlaceType_descriptor(), name, value);
}
enum PropType : int {
  NullPropType = 0,
  addHP = 1,
  addAP = 2,
  addSpeed = 3,
  addLIFE = 4,
  minusCD = 5,
  Gem = 6,
  Shield = 7,
  Spear = 8,
  minusSpeed = 9,
  minusAP = 10,
  addCD = 11,
  PropType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PropType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PropType_IsValid(int value);
constexpr PropType PropType_MIN = NullPropType;
constexpr PropType PropType_MAX = addCD;
constexpr int PropType_ARRAYSIZE = PropType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PropType_descriptor();
template<typename T>
inline const std::string& PropType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PropType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PropType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PropType_descriptor(), enum_t_value);
}
inline bool PropType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PropType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PropType>(
    PropType_descriptor(), name, value);
}
enum PassiveSkillType : int {
  NullPassiveSkillType = 0,
  RecoverAfterBattle = 1,
  SpeedUpWhenLeavingGrass = 2,
  Vampire = 3,
  PSkill3 = 4,
  PSkill4 = 5,
  PSkill5 = 6,
  PassiveSkillType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  PassiveSkillType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool PassiveSkillType_IsValid(int value);
constexpr PassiveSkillType PassiveSkillType_MIN = NullPassiveSkillType;
constexpr PassiveSkillType PassiveSkillType_MAX = PSkill5;
constexpr int PassiveSkillType_ARRAYSIZE = PassiveSkillType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PassiveSkillType_descriptor();
template<typename T>
inline const std::string& PassiveSkillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, PassiveSkillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function PassiveSkillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    PassiveSkillType_descriptor(), enum_t_value);
}
inline bool PassiveSkillType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, PassiveSkillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<PassiveSkillType>(
    PassiveSkillType_descriptor(), name, value);
}
enum ActiveSkillType : int {
  NullActiveSkillType = 0,
  BecomeVampire = 1,
  BecomeAssassin = 2,
  NuclearWeapon = 3,
  SuperFast = 4,
  ASkill4 = 5,
  ASkill5 = 6,
  ActiveSkillType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ActiveSkillType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ActiveSkillType_IsValid(int value);
constexpr ActiveSkillType ActiveSkillType_MIN = NullActiveSkillType;
constexpr ActiveSkillType ActiveSkillType_MAX = ASkill5;
constexpr int ActiveSkillType_ARRAYSIZE = ActiveSkillType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ActiveSkillType_descriptor();
template<typename T>
inline const std::string& ActiveSkillType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ActiveSkillType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ActiveSkillType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ActiveSkillType_descriptor(), enum_t_value);
}
inline bool ActiveSkillType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ActiveSkillType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ActiveSkillType>(
    ActiveSkillType_descriptor(), name, value);
}
enum BuffType : int {
  NullBuffType = 0,
  MoveSpeed = 1,
  AP = 2,
  CD = 3,
  AddLIFE = 4,
  ShieldBuff = 5,
  SpearBuff = 6,
  BuffType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BuffType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BuffType_IsValid(int value);
constexpr BuffType BuffType_MIN = NullBuffType;
constexpr BuffType BuffType_MAX = SpearBuff;
constexpr int BuffType_ARRAYSIZE = BuffType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BuffType_descriptor();
template<typename T>
inline const std::string& BuffType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BuffType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BuffType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BuffType_descriptor(), enum_t_value);
}
inline bool BuffType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BuffType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BuffType>(
    BuffType_descriptor(), name, value);
}
enum BulletType : int {
  NullBulletType = 0,
  CommonBullet1 = 1,
  CommonBullet2 = 2,
  CommonBullet3 = 3,
  CommonBullet4 = 4,
  AtomBomb = 5,
  BulletType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  BulletType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool BulletType_IsValid(int value);
constexpr BulletType BulletType_MIN = NullBulletType;
constexpr BulletType BulletType_MAX = AtomBomb;
constexpr int BulletType_ARRAYSIZE = BulletType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* BulletType_descriptor();
template<typename T>
inline const std::string& BulletType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, BulletType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function BulletType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    BulletType_descriptor(), enum_t_value);
}
inline bool BulletType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, BulletType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<BulletType>(
    BulletType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace Protobuf

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Protobuf::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::MessageType>() {
  return ::Protobuf::MessageType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::GameObjType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::GameObjType>() {
  return ::Protobuf::GameObjType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::ShapeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::ShapeType>() {
  return ::Protobuf::ShapeType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::PlaceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::PlaceType>() {
  return ::Protobuf::PlaceType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::PropType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::PropType>() {
  return ::Protobuf::PropType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::PassiveSkillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::PassiveSkillType>() {
  return ::Protobuf::PassiveSkillType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::ActiveSkillType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::ActiveSkillType>() {
  return ::Protobuf::ActiveSkillType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::BuffType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::BuffType>() {
  return ::Protobuf::BuffType_descriptor();
}
template <> struct is_proto_enum< ::Protobuf::BulletType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Protobuf::BulletType>() {
  return ::Protobuf::BulletType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_MessageType_2eproto
